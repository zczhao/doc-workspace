

# JDK

## 1、环境变量

```
JAVA_HOME
C:\Java\jdk1.8.0_202

CLASSPATH
.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar

Path
%JAVA_HOME%\bin
%JAVA_HOME%\jre\bin
```

# Ant

## 1、环境变量

```
ANT_HOME
C:\apache-ant-1.9.14

Path
%ANT_HOME%\bin
```

# Maven

## 1、环境变量

```
MAVEN_HOME
C:\apache-maven-3.6.0

Path
%MAVEN_HOME%\bin
```

## 2、命令行创建项目

### 2.1、创建普通Java项目

```
mvn archetype:generate -DgroupId=com.zzc -DartifactId=maven-java -DarchetypeArtifactId=maven-archetype-quickstart
```

### 2.2、创建JavaWeb项目

```
mvn archetype:generate -DgroupId=com.zzc -DartifactId=maven-javaweb -DarchetypeArtifactId=maven-archetype-webapp
```

### 2.2、导入eclipse

```
File->Import...->Maven->Existing Maven Projects
```

## 3、maven 转 gradle 项目

```
gradle init --type pom
```

## 4、将项目打成可执行的jar包

### 1、maven-shade-plugin

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-shade-plugin</artifactId>
    <version>3.2.1</version>
    <executions>
        <execution>
            <!-- 执行package的phase -->
            <phase>package</phase>
            <!-- 为这个phase绑定goal -->
            <goals>
                <goal>shade</goal>
            </goals>
            <configuration>
                <transformers>
                    <!-- 打成可执行的jar包 的主方法入口 -->
                    <transformer
                                 implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                        <mainClass>zzc.App</mainClass>
                    </transformer>
                </transformers>
            </configuration>
        </execution>
    </executions>
</plugin>
```

```shell
mvn clean package
cd target
java -jar xxx.jar
```

### 2、maven-assembly-plugin

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-assembly-plugin</artifactId>
    <version>3.1.1</version>
    <configuration>
        <descriptorRefs>
            <descriptorRef>jar-with-dependencies</descriptorRef>
        </descriptorRefs>
        <archive>
            <manifest>
                <mainClass>zzc.App</mainClass>
            </manifest>
        </archive>
    </configuration>
    <executions>
        <execution>
            <id>make-assembly</id>
            <phase>package</phase>
            <goals>
                <goal>single</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

```shell
mvn clean package
cd target
java -jar xxx-jar-with-dependencies.jar
```

### 3、onejar-maven-plugin

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-jar-plugin</artifactId>
    <version>3.1.1</version>
    <configuration>
        <archive>
            <manifest>
                <mainClass>zzc.App</mainClass>
            </manifest>
        </archive>
    </configuration>
</plugin>

<plugin>
    <groupId>com.jolira</groupId>
    <artifactId>onejar-maven-plugin</artifactId>
    <version>1.4.4</version>
    <executions>
        <execution>
            <configuration>
                <attachToBuild>true</attachToBuild>
                <classifier>onejar</classifier>
            </configuration>
            <goals>
                <goal>one-jar</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

```shell
mvn clean package
cd target
java -jar xxx.jar
java -jar xxx.one-jar.jar
```

### 4、使用maven-jar-plugin和maven-dependency-plugin打可执行包,引用的包放包外面文件夹下

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-jar-plugin</artifactId>
    <version>3.1.1</version>
    <configuration>
        <excludes>
            <exclude>**/*.log</exclude>
        </excludes>
        <archive>
            <manifest>
                <addClasspath>true</addClasspath>
                <mainClass>zzc.App</mainClass>
                <classpathPrefix>lib/</classpathPrefix>
            </manifest>
        </archive>
    </configuration>
</plugin>

<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-dependency-plugin</artifactId>
    <version>3.1.1</version>
    <executions>
        <execution>
            <id>copy-dependencies</id>
            <phase>package</phase>
            <goals>
                <goal>copy-dependencies</goal>
            </goals>
            <configuration>
                <!-- exclude junit, we need runtime dependency only -->
                <includeScope>runtime</includeScope>
                <outputDirectory>${project.build.directory}/lib/</outputDirectory>
            </configuration>
        </execution>
    </executions>
</plugin>
```

```shell
mvn clean package
cd target
java -jar xxx.jar
```

maven-shade-plugin和maven-assembly-plugin采取的是将依赖包解压再一并打到新包中,这样依赖包可能存在冲突的时候,
导致运行时可能出现未知问题,而onejar-maven-plugin打包是将依赖包自动归入lib目录,不解压原包,相当于在原包基础上加壳, 这样可以避免冲突的发生。第四种方法即是原来ant打包所使用的方法

## 5、IDEA资源项目非class文件打包/部署

```xml
<project>
    <name>HelloWorld</name>
    <plugins>
        <!-- 
		为了使项目结构更为清晰，Maven区别对待Java代码文件和资源文件，maven-compiler-plugin用来编译Java代码，maven-resources-plugin则用来处理资源文件。

默认的主资源文件目录是src/main/resources，很多用户会需要添加额外的资源文件目录，这个时候就可以通过配置maven-resources-plugin来实现。

		利用此plugin，把源代码中的xml文件，打包到相应位置 
		-->
    	<plugin>
        	<artifactId>maven-resources-plugin</artifactId>
            <version>2.5</version>
            <executions>
                <execution>
                    <id>copy-xmls</id>
                    <phase>process-sources</phase>
                    <goals>
                        <goal>copy-resources</goal>
                    </goals>
                    <configuration>
                        <outputDirectory>${basedir}/target/classes</outputDirectory>
                        <resources>
                            <resource>
                                <directory>${basedir}/src/main/java</directory>
                                <includes>
                                    <include>**/*.xml</include>
                                </includes>
                            </resource>
                        </resources>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
    <build>
        <!-- 资源目录 -->
        <resources>
            <resource>
                <!-- 设定主资源目录 -->
                <directory>src/main/java</directory>
                <!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，只处理如下配置中包含的资源类型 -->
                <includes>
                    <include>**/*.hbm.xml</include>
                </includes>
                <!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，不处理如下配置中包含的资源类型（剔除下如下配置中包含的资源类型） -->
                <excludes>
                    <exclude>**/*.yaml</exclude>
                </excludes>
                 <!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，指定处理后的资源文件输出目录，默认是${build.outputDirectory}指定的目录-->
                <!--<targetPath>${build.outputDirectory}</targetPath> --> 
                <!-- maven default生命周期，process-resources阶段执行maven-resources-plugin插件的resources目标处理主资源目下的资源文件时，是否对主资源目录开启资源过滤 -->
                 <filtering>true</filtering>
            </resource>
            <resource>
                <!-- 指定资源文件的位置 -->
                <directory>src/main/resources</directory>
                <!-- filtering：开启过滤，用指定的参数替换directory下的文件中的参数(eg. ${name}) -->
                <filtering>true</filtering>
            </resource>
        </resources>
    </build>
</project>

<!-- 然后在src/main/resources下，添加一个文件，比如叫test.txt。test.txt内容如下：-->
I want to say :　${name}

<!-- 执行 mvn resources:resources 命令，最后会在target/classes下看到test.txt的内容变成了，如下所示： -->
I want to say : HelloWorld
```

```xml
<project>
    <name>HelloWorld</name>

    <properties>
    	<username>Tom</username>
    </properties>
    
    <build>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>true</filtering>
            </resource>
        </resources>
    </build>
</project>

<!-- 然后在test.txt，添加一句： -->
My name is ${username}
```

```xml
<project>
   
    <filters>
    	<filter>src/main/resources/code.properties</filter>
    </filters>
    
    <build>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>true</filtering>
            </resource>
        </resources>
    </build>
</project>

<!--
在src/main/resources下添加文件code.properties
该文件内容如下
-->
username1=tom1
password=123

<!-- 
然后test.txt，添加如：${username1}  ${password} 
执行 mvn resources:resources 命令，最后会在target/classes下看到test.txt的内容变成了，如下所示： 
-->
I want to say : tom1-123
```

```xml
<!--过滤resource下的文件-->
<resources> 
  <resource> 
    <directory>src/main/resources</directory>  
    <includes> 
      <include>*.properties</include>  
      <!--打包properties文件--> 
    </includes>  
    <excludes> 
      <exclude>*.xml</exclude>  
      <!--过滤xml与yaml文件-->  
      <exclude>*.yaml</exclude> 
    </excludes> 
  </resource> 
</resources>

<!-- 默认resources目录下的文件都会被打包，如果想resources目录下的xml文件不被打包，可通过如下配置: -->
<plugin> 
  <artifactId>maven-resources-plugin</artifactId>  
  <executions> 
    <execution> 
      <id>copy-resources</id>  
      <phase>validate</phase>  
      <goals> 
        <goal>copy-resources</goal> 
      </goals>  
      <configuration> 
        <!-- 并把文件复制到target/conf目录下-->  
        <outputDirectory>${project.build.directory}/conf</outputDirectory>  
        <resources> 
          <resource> 
            <directory>src/main/resources</directory>  
            <!-- 指定不需要处理的资源 <excludes> <exclude>WEB-INF/*.*</exclude> </excludes> --> 
            <excludes> 
              <exclude>**/*.xml</exclude> 
            </excludes>  
            <filtering>true</filtering> 
          </resource> 
        </resources> 
      </configuration> 
    </execution> 
  </executions> 
</plugin>
```

# Gradle

## 1、环境变量

```
GRADLE_HOME
C:\gradle-5.3.1

GRADLE_USER_HOME
C:\workspace\repo

Path
%GRADLE_HOME%\bin
```

## 2、命令行创建项目

### 2.1、创建普通Java项目

build.gradle

```groovy
apply plugin: "java"
apply plugin: "eclipse"

task createJavaProject {
    sourceSets*.java.srcDirs*.each { it.mkdirs() }
    sourceSets*.resources.srcDirs*.each { it.mkdirs()}
}
```

```java
gradle createJavaProject eclipse
```

### 2.2、创建JavaWeb项目

build.gradle

```groovy
apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'war'

task createJavaProject {
    sourceSets*.java.srcDirs*.each { it.mkdirs() }
    sourceSets*.resources.srcDirs*.each { it.mkdirs()}
}
```

```
gradle createWebProject eclipse
```

## 3、gradle 转 maven 项目

build.gradle

```groovy
apply plugin: 'maven'
```

```
gradle install
```

根目录的build文件夹下会生成了一个poms文件夹，里面包含需要的pom文件

## 4、将项目打成可执行的jar包

```groovy
apply plugin: "java"
apply plugin: "eclipse"

dependencies {
	compile "org.jsoup:jsoup:1.11.3"
}

jar {
    manifest {
    	attributes("Main-Class": "zzc.App","Implementation-Title": "Gradle")
    }    
    into('lib') {
    	from configurations.runtime
    }
}
```

```shell
gradle build
cd build/libs
java -jar xxx.jar
```

